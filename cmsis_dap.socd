--[[
 * SmartOCD CMSIS-DAP操作
 * Date:2018年04月20日22:13:45
 * Author: Virus.V <virusv@live.com>
]]
adapter = require("Adapter");	-- 加载Adapter库
cmsis_dap = require("CMSIS-DAP"); -- 加载CMSIS-DAP库
cmsis_dapObj = cmsis_dap.new(); -- 创建新的CMSIS-DAP对象
-- CMSIS-DAP的VID和PID
local vid_pids = {
	-- Keil Software
	{0xc251, 0xf001},	-- LPC-Link-II CMSIS_DAP
	{0xc251, 0xf002}, 	-- OPEN-SDA CMSIS_DAP (Freedom Board)
	{0xc251, 0x2722}, 	-- Keil ULINK2 CMSIS-DAP
	-- MBED Software
	{0x0d28, 0x0204}	-- MBED CMSIS-DAP
}
-- 连接CMSIS-DAP仿真器
cmsis_dap.connect(cmsis_dapObj, vid_pids, nil)
-- 初始化Adapter对象
cmsis_dapObj:init()
-- 配置CMSIS-DAP Transfer参数
cmsis_dap.transferConfigure(cmsis_dapObj, 5, 5, 5)
-- SWD参数
cmsis_dap.swdConfigure(cmsis_dapObj, 0)
-- 点亮连接状态指示灯
cmsis_dapObj:setStatus(adapter.STATUS_CONNECTED)
cmsis_dapObj:setClock(10000000)	-- 10MHz
if not cmsis_dapObj:haveTransmission(adapter.JTAG) then
	error("Emmm.. This adapter does not support JTAG Transmission.")
end
cmsis_dapObj:selectTransmission(adapter.JTAG)
cmsis_dapObj:setStatus(adapter.STATUS_RUNING)

-- 读取JTAG Pins
local pins_data = cmsis_dapObj:jtagPins(0, 0, 0)
print("JTAG Pins " .. pins_data)
-- -- 引入DAP相关包
-- dap = require("DAP")
-- -- 创建DAP对象，使用CMSIS-DAP作为Adapter
-- dapObj = dap.new(cmsis_dapObj)
-- -- 设置TAP信息，一共两个TAP，第一个TAP的指令寄存器长度为4,第二个指令寄存器长度为5
-- dapObj:setInfo({4})
-- dapObj:reset(false);	-- TAP soft reset
-- local idcodes = dapObj:get_IDCODE()
-- print("===========Found " .. #idcodes .." TAPs===========")
-- for k,v in ipairs(idcodes) do
-- 	print(string.format("JTAG index %d => IDCODE:0x%08X", k, v))
-- end

-- dapObj:set_TAP(0)	-- 设置JTAG模式下当前DAP使用的TAP在JTAG扫描链中的索引，SW模式下忽略
-- dapObj:setDelay(5)	-- 设置Memory等待周期数，等待内存操作完成。在慢速设备上有助于减少指令WAIT响应次数
-- -- 清除Sticky Flags
-- dapObj:write_DP(DAP_Reg.DP_CTRL_STAT, 0x32)	
-- -- dapObj:writeAbort(0x1F)	-- 清除所有错误标志 S5P6818 是DPv0，所以Abort只有DAP Abort位
-- -- 将SELECT寄存器清零
-- dapObj:write_DP(DAP_Reg.DP_SELECT, 0)
-- -- System domain power up && Debug domain power up
-- dapObj:write_DP(DAP_Reg.DP_CTRL_STAT, 0x40000000 | 0x10000000 | 0x32)
-- local ctrl_status
-- repeat 
-- 	ctrl_status = dapObj:read_DP(DAP_Reg.DP_CTRL_STAT)
-- until ctrl_status & (0x20000000 | 0x80000000) == (0x20000000 | 0x80000000)
-- print("System and Debug Power up.")
-- -- 写入MASK LANE和OVERRUN Detection
-- dapObj:write_DP(DAP_Reg.DP_CTRL_STAT, 0x40000000 | 0x10000000 | 0x00000F01 | 0x32)	
-- -- 检查错误
-- local err, ctrl_stat = dapObj:checkError()
-- if not err then 
-- 	error(string.format( "CTRL/STATUS: %08X", ctrl_stat)) 
-- else
-- 	print(string.format( "CTRL/STATUS: %08X", ctrl_stat))
-- end

--[[
0x80001000 => 0x00001003.
0x80002000 => 0x00002003.
0x80003000 => 0x00003003.
0x80004000 => 0x00004003.
0x80005000 => 0x00005003.
0x80006000 => 0x00006003.
0x80009000 => 0x00009003.
0x80020000 => 0x00020003. * Component CID:0xB105900D, PID:0x04003BB9A8.
0x80040000 => 0x00040003. * Component CID:0xB105900D, PID:0x04003BB95D.
0x80060000 => 0x00060003.
0x80080000 => 0x00080003.
]]
--[[
local cid, pid = dapObj:get_CID_PID(0x80001000)
if (cid & 0xFFFF0FFF) ~= 0xB105000D then
	-- 无效的CID
	print("Invaild CID:" .. string.format("%08X", cid))
	return 
end
print(string.format( "Component CID:0x%08X, PID:0x%010X.", cid, pid))
]]

-- 选择AP0 AXI 总线
--[[
dapObj:select_AP(0)
local ap_idr = dapObj:read_AP(0xFC)
-- 打印当前ap信息
print(dap.parse_APIDR(ap_idr))


local csw = dapObj:read_AP(DAP_Reg.AP_CSW)
print(string.format( "CSW Register: %08X", csw ))
-- 设置AP控制字,32位读取
dapObj:write_AP(DAP_Reg.AP_CSW, csw | 0x2)

local APB_AP_Idx = dapObj:find_AP("APB")   -- 这里先选择AHB总线，测试用

local csw = dapObj:read_AP(DAP_Reg.AP_CSW)
print(string.format( "CSW Register: %08X", csw ))
-- 设置AP控制字,32位读取
dapObj:write_AP(DAP_Reg.AP_CSW, csw | 0x2)

]]


cmsis_dapObj:setStatus(adapter.STATUS_IDLE)
-- 反初始化Adapter对象后禁止操作TAP对象和DAP对象
-- cmsis_dapObj:deinit()

